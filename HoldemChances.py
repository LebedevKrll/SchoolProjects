

'''HoldemChances is counting you chance at winning a round of Texas hold em
It will work with as much info as you give it, even 2 cards will be enough for it to count.
Works with +-0.01% accuracy'''

# -*- coding: utf-8 -*-
"""hold_em.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1l4ThmGJNQvj0wGJvsz4Cvgu9IVJ5F9IC
"""

from copy import deepcopy
from itertools import combinations, product
import collections

def count_win_probabilities(players_private_cards, known_community_cards, already_dropped_cards):
    
    true_hands = []
    board = deepcopy(known_community_cards)
    final_res = []
    for player_num in range(len(players_private_cards)):
        final_res.append(0)
    num_of_mystery = 5 - len(board)
    discard = already_dropped_cards
    suits = ['C', 'H', 'D', 'S']
    ranks = ['2', '3', '4', '5', '6', '7', '8', '9', '10', 'J', 'Q', 'K', 'A']
    num_of_possible_matches = 0
    players_hands = deepcopy(players_private_cards)

    for i in players_hands:
        card_sum = []
        for j in i:
            if 'A' in j:
                card_sum.append(j.replace('A', '14'))
            elif 'K' in j:
                card_sum.append(j.replace('K', '13'))
            elif 'Q' in j:
                card_sum.append(j.replace('Q', '12'))
            elif 'J' in j:
                card_sum.append(j.replace('J', '11'))
            else:
                card_sum.append(j)
        true_hands.append(card_sum)

    if len(known_community_cards) < 5:
        dec_mult = []
        all_cards = []
        for random_card in product(ranks, suits):
            dec_mult.append(random_card)

        for strange_pair in dec_mult:
            all_cards.append(strange_pair[0] + strange_pair[1])

        for known_comm_card in known_community_cards:
            all_cards.remove(known_comm_card)
        for pl in players_private_cards:
            for pl_card in pl:
                all_cards.remove(pl_card)
        for already_dropped_card in already_dropped_cards:
            all_cards.remove(already_dropped_card)
        
        for imagined_cards in combinations(all_cards, num_of_mystery):
            board = deepcopy(known_community_cards)
            num_of_possible_matches += 1
            true_board = []
            for imagined_card in imagined_cards:
                board.append(imagined_card)
                
            for i in board:
                if 'A' in i:
                   true_board.append(i.replace('A', '14'))
                elif 'K' in i:
                    true_board.append(i.replace('K', '13'))
                elif 'Q' in i:
                    true_board.append(i.replace('Q', '12'))
                elif 'J' in i:
                    true_board.append(i.replace('J', '11'))
                else:
                    true_board.append(i)

            combs = check_combs(true_hands, true_board)
            intermediate_res = combs_comparison(combs)
            for index in range(len(final_res)):
                final_res[index] += intermediate_res[index]
        for index in range(len(final_res)):
            final_res[index] /= num_of_possible_matches
        return final_res
    
    true_board = []
    for i in board:
        if 'A' in i:
            true_board.append(i.replace('A', '14'))
        elif 'K' in i:
            true_board.append(i.replace('K', '13'))
        elif 'Q' in i:
            true_board.append(i.replace('Q', '12'))
        elif 'J' in i:
            true_board.append(i.replace('J', '11'))
        else:
            true_board.append(i)
    
    combs = check_combs(true_hands, true_board)
    return combs_comparison(combs)

def check_combs(player_hands, board):
    players_combs = []
    for d in player_hands:
        available_cards = d + board
        Clubs = []
        Hearts = []
        Diamonds = []
        Spades = []
        i = 0
        straight_availability = False
        straight_main_card = 0
        straight_availability_strfl = False
        straight_main_card_strfl = 0
        for j in available_cards:
            if 'C' in j:
                available_cards[i] = j.replace('C', '')
                Clubs.append(int(available_cards[i]))
            elif 'H' in j:
                available_cards[i] = j.replace('H', '')
                Hearts.append(int(available_cards[i]))
            elif 'D' in j:
                available_cards[i] = j.replace('D', '')
                Diamonds.append(int(available_cards[i]))
            elif 'S' in j:
                available_cards[i] = j.replace('S', '')
                Spades.append(int(available_cards[i]))
            available_cards[i] = int(available_cards[i])
            i += 1
        if max(len(Clubs), len(Spades), len(Diamonds), len(Hearts)) == len(Clubs):
            lear = Clubs
        elif max(len(Clubs), len(Spades), len(Diamonds), len(Hearts)) == len(Hearts):
            lear = Hearts
        elif max(len(Clubs), len(Spades), len(Diamonds), len(Hearts)) == len(Diamonds):
            lear = Diamonds
        else:
            lear = Spades

        counted_cards = collections.Counter(available_cards)
        
        if 14 in available_cards and 5 in available_cards and 4 in available_cards and 3 in available_cards and 2 in available_cards:
            straight_availability = True
            straight_main_card = 5
        
        try:
            if sorted(list(set(available_cards)),
reverse=True)[0] - sorted(list(set(available_cards)),
reverse=True)[4] == 4 and len(list(set(available_cards))[0 : 5]) == len(available_cards[0 : 5]):
                straight_availability = True
                straight_main_card = sorted(available_cards,
reverse=True)[0]
            elif sorted(list(set(available_cards)),
reverse=True)[1] - sorted(list(set(available_cards)),
reverse=True)[5] == 4 and len(list(set(available_cards))[1 : 6]) == len(available_cards[1 : 6]):
                straight_availability = True
                straight_main_card = sorted(list(set(available_cards)),
reverse=True)[1]
            elif sorted(list(set(available_cards)),
reverse=True)[2] - sorted(list(set(available_cards)),
reverse=True)[6] == 4 and len(list(set(available_cards))[2 : 7]) == len(available_cards[2 : 7]):
                straight_availability = True
                straight_main_card = sorted(list(set(available_cards)),
reverse=True)[2]
        except IndexError:
            pass

        if 14 in lear and 5 in lear and 4 in lear and 3 in lear and 2 in lear:
            straight_availability_strfl = True
            straight_main_card_strfl = 5

        try:
            if sorted(list(set(lear)),
reverse=True)[0] - sorted(list(set(lear)),
reverse=True)[4] == 4 and len(list(set(lear))[0 : 5]) == len(lear[0 : 5]):
                straight_availability_strfl = True
                straight_main_card_strfl = sorted(lear,
reverse=True)[0]
            elif sorted(list(set(lear)),
reverse=True)[1] - sorted(list(set(lear)),
reverse=True)[5] == 4 and len(list(set(lear))[1 : 6]) == len(lear[1 : 6]):
                straight_availability_strfl = True
                straight_main_card_strfl = sorted(list(set(lear)),
reverse=True)[1]
            elif sorted(list(set(lear)),
reverse=True)[2] - sorted(list(set(lear)),
reverse=True)[6] == 4 and len(list(set(lear))[2 : 7]) == len(lear[2 : 7]):
                straight_availability_strfl = True
                straight_main_card_strfl = sorted(list(set(lear)),
reverse=True)[2]
        except IndexError:
            pass

        if [14, 13, 12, 11, 10] in sorted(Clubs) or [14, 13, 12, 11, 10] in sorted(Spades) or [14, 13, 12, 11, 10] in sorted(Hearts) or [14, 13, 12, 11, 10] in sorted(Diamonds):
            players_combs.append([9])
        elif straight_availability_strfl == True and (len(Clubs) >= 5 or len(Spades) >= 5 or len(Hearts) >= 5 or len(Diamonds) >= 5):
            players_combs.append([8, straight_main_card_strfl])
        elif counted_cards.most_common(1)[0][1] == 4:
            a = counted_cards.most_common(1)[0][0]
            counted_cards.pop(a)
            b = []
            for i in counted_cards:
                b.append(i)
            players_combs.append([7, a, max(b)])
        elif counted_cards.most_common(2)[0][1] == 3 and counted_cards.most_common(2)[1][1] >= 2:
            players_combs.append([6] + [counted_cards.most_common(2)[0][0]] + [counted_cards.most_common(2)[1][0]])
        elif len(Clubs) >= 5 or len(Spades) >= 5 or len(Hearts) >= 5 or len(Diamonds) >= 5:
            players_combs.append([5] + sorted(lear, reverse=True)[0 : 5])
        elif straight_availability == True:
            players_combs.append([4, straight_main_card])
        elif counted_cards.most_common(2)[0][1] == 3 and counted_cards.most_common(2)[1][1] == 1:
            a = counted_cards.most_common(1)[0][0]
            counted_cards.pop(a)
            b = []
            for i in counted_cards:
                b.append(i)
            players_combs.append([3, a] + sorted(b, reverse=True)[0 : 2])
        elif counted_cards.most_common(2)[0][1] == 2 and counted_cards.most_common(2)[1][1] == 2:
            if counted_cards.most_common(3)[2][1] == counted_cards.most_common(3)[0][1]:
                t = []
                for q in counted_cards.most_common(3):
                    t.append(q[0])
                a = max(t)
                counted_cards.pop(a)
                t.remove(a)
                b = max(t)
                counted_cards.pop(b)
            else:
                a = counted_cards.most_common(1)[0][0]
                counted_cards.pop(a)
                b = counted_cards.most_common(1)[0][0]
                counted_cards.pop(b)
            c = []
            for i in counted_cards:
                c.append(i)
            players_combs.append([2, max(a, b), min(a, b), max(c)])
        elif counted_cards.most_common(2)[0][1] == 2 and counted_cards.most_common(2)[1][1] == 1:
            a = counted_cards.most_common(1)[0][0]
            counted_cards.pop(a)
            b = []
            for i in counted_cards:
                b.append(i)
            players_combs.append([1, a] + sorted(b, reverse=True)[0 : 3])
        else:
            players_combs.append([0] + sorted(available_cards, reverse=True)[0 : 5])
    return players_combs

def combs_comparison(players_combs):
    winners = []
    for i in players_combs:
        winners.append(0)
    if sorted(players_combs, reverse=True)[0] != sorted(players_combs, reverse=True)[1]:
        winners[players_combs.index(max(players_combs))] += 1
    else:
        devider = 0
        for i in range(len(players_combs)):
            if players_combs[i] == max(players_combs):
                winners[i] += 1
                devider += 1
        for i in range(len(winners)):
            winners[i] /= devider
    return winners

    